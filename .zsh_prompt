#!/usr/bin/env zsh

# Shell prompt based on the Solarized Dark theme.
# Screenshot: http://i.imgur.com/EkEtphC.png
# Heavily inspired by @necolas's prompt: https://github.com/necolas/dotfiles
# iTerm → Profiles → Text → use 13pt Monaco with 1.1 vertical spacing.

# Enable colors
autoload -U colors && colors

prompt_git() {
	local s=''
	local branchName=''

	# Check if the current directory is in a Git repository.
	git rev-parse --is-inside-work-tree &>/dev/null || return

	# Check for what branch we're on.
	# Get the short symbolic ref. If HEAD isn't a symbolic ref, get a
	# tracking remote branch or tag. Otherwise, get the
	# short SHA for the latest commit, or give up.
	branchName="$(git symbolic-ref --quiet --short HEAD 2>/dev/null || \
		git describe --all --exact-match HEAD 2>/dev/null || \
		git rev-parse --short HEAD 2>/dev/null || \
		echo '(unknown)')"

	# Early exit for Chromium & Blink repo, as the dirty check takes too long.
	# Thanks, @paulirish!
	# https://github.com/paulirish/dotfiles/blob/dd33151f/.bash_prompt#L110-L123
	repoUrl="$(git config --get remote.origin.url)"
	if [[ "$repoUrl" == *'chromium/src.git'* ]]; then
		s+='*'
	else
		# Check for uncommitted changes in the index.
		if ! git diff --quiet --ignore-submodules --cached; then
			s+='+'
		fi
		# Check for unstaged changes.
		if ! git diff-files --quiet --ignore-submodules --; then
			s+='!'
		fi
		# Check for untracked files.
		if [[ -n "$(git ls-files --others --exclude-standard)" ]]; then
			s+='?'
		fi
		# Check for stashed files.
		if git rev-parse --verify refs/stash &>/dev/null; then
			s+='$'
		fi
	fi

	[[ -n "${s}" ]] && s=" [${s}]"

	echo "${1}${branchName}${2}${s}"
}

# Define colors using zsh color syntax
if [[ "$TERM" == *256color* ]] || [[ "$TERM" == xterm* ]]; then
	# Catppuccin Mocha colors
	bold="%B"
	reset="%b%f"
	black="%F{236}"     # #313244 (Surface0)
	blue="%F{111}"      # #89b4fa (Blue)
	cyan="%F{116}"      # #94e2d5 (Teal)
	green="%F{114}"     # #a6e3a1 (Green)
	orange="%F{209}"    # #fab387 (Peach)
	purple="%F{183}"    # #cba6f7 (Mauve)
	red="%F{210}"       # #f38ba8 (Red)
	violet="%F{141}"    # #b4befe (Lavender)
	white="%F{254}"     # #cdd6f4 (Text)
	yellow="%F{221}"    # #f9e2af (Yellow)
else
	bold="%B"
	reset="%b%f"
	black="%F{black}"
	blue="%F{blue}"
	cyan="%F{cyan}"
	green="%F{green}"
	orange="%F{yellow}"
	purple="%F{magenta}"
	red="%F{red}"
	violet="%F{magenta}"
	white="%F{white}"
	yellow="%F{yellow}"
fi

# Highlight the user name when logged in as root.
if [[ "${USER}" == "root" ]]; then
	userStyle="${red}"
else
	userStyle="${orange}"
fi

# Highlight the hostname when connected via SSH.
if [[ -n "${SSH_TTY}" ]]; then
	hostStyle="${bold}${red}"
else
	hostStyle="${yellow}"
fi

# Enable prompt substitution
setopt PROMPT_SUBST

# Set the terminal title and prompt.
precmd() {
	# Set terminal title to current directory
	print -Pn "\e]0;%1~\a"
}

# Build the prompt
PROMPT='${bold}
${userStyle}%n${reset}'        # username
PROMPT+='${white} at '
PROMPT+='${hostStyle}%m${reset}'  # hostname
PROMPT+='${white} in '
PROMPT+='${green}%~${reset}'      # working directory full path
PROMPT+='$(prompt_git "${white} on ${violet}" "${blue}")'  # Git repository details
PROMPT+='
${white}\$ ${reset}'              # `$` (and reset color)

# Continuation prompt
PROMPT2='${yellow}→ ${reset}'

